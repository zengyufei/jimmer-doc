"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[6154],{11724:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"cache/consistency","title":"Cache Consistency","description":"In previous articles on object cache, association cache, and calculated cache, we have discussed in detail how Jimmer automatically deletes affected caches when data is modified.","source":"@site/docs/cache/consistency.mdx","sourceDirName":"cache","slug":"/cache/consistency","permalink":"/jimmer-doc/docs/cache/consistency","draft":false,"unlisted":false,"editUrl":"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/cache/consistency.mdx","tags":[],"version":"current","lastUpdatedAt":1704015848000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Cache Consistency"},"sidebar":"tutorialSidebar","previous":{"title":"Calculated Cache","permalink":"/jimmer-doc/docs/cache/cache-type/calculation"},"next":{"title":"Multi-view Cache","permalink":"/jimmer-doc/docs/cache/multiview-cache/"}}');var c=t(74848),s=t(28453);const a={sidebar_position:3,title:"Cache Consistency"},o=void 0,r={},l=[{value:"Consistency of BinLog Trigger (Recommended)",id:"consistency-of-binlog-trigger-recommended",level:2},{value:"Consistency of Transaction Trigger",id:"consistency-of-transaction-trigger",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(i.admonition,{type:"caution",children:[(0,c.jsxs)(i.p,{children:["In previous articles on ",(0,c.jsx)(i.a,{href:"./cache-type/object",children:"object cache"}),", ",(0,c.jsx)(i.a,{href:"./cache-type/association",children:"association cache"}),", and ",(0,c.jsx)(i.a,{href:"./cache-type/calculation",children:"calculated cache"}),", we have discussed in detail how Jimmer automatically deletes affected caches when data is modified."]}),(0,c.jsx)(i.p,{children:"So here we will not repeat the discussion of how Jimmer intelligently invalidates affected caches."}),(0,c.jsx)(i.p,{children:"The focus of this article is how Jimmer ensures cache deletion operations issued can definitely succeed."})]}),"\n",(0,c.jsxs)(i.p,{children:["Whether it is the fully automatic invalidation of ",(0,c.jsx)(i.a,{href:"./cache-type/object",children:"object cache"})," and ",(0,c.jsx)(i.a,{href:"./cache-type/association",children:"association cache"}),", or the user assisted invalidation of ",(0,c.jsx)(i.a,{href:"./cache-type/calculation",children:"calculated cache"}),", the cache consistency of Jimmer is driven by ",(0,c.jsx)(i.a,{href:"../mutation/trigger",children:"triggers"}),"."]}),"\n",(0,c.jsx)(i.p,{children:"Jimmer triggers are divided into BinLog triggers and Transaction triggers."}),"\n",(0,c.jsx)(i.p,{children:"For different situations, Jimmer adopts different strategies to ensure cache consistency, that is, to ensure that cache invalidation operations must succeed."}),"\n",(0,c.jsx)(i.h2,{id:"consistency-of-binlog-trigger-recommended",children:"Consistency of BinLog Trigger (Recommended)"}),"\n",(0,c.jsxs)(i.p,{children:["When ",(0,c.jsx)(i.code,{children:"trigger-type"})," is ",(0,c.jsx)(i.code,{children:"BINLOG_ONLY"})," or ",(0,c.jsx)(i.code,{children:"BOTH"}),", Jimmer uses the BinLog trigger to invalidate caches."]}),"\n",(0,c.jsxs)(i.p,{children:["In this case, developers respond to messaging queue notifications, process them simply and then call Jimmer's ",(0,c.jsx)(i.code,{children:"BinLog"})," API ",(0,c.jsx)(i.em,{children:"(this user code is very simple, and its complexity can be ignored)"}),". Calling the ",(0,c.jsx)(i.code,{children:"BinLog"})," API initiates all trigger callbacks, including cache invalidation."]}),"\n",(0,c.jsxs)(i.p,{children:["Take Kafka as an example, make sure to commit the consumption progress after successfully calling the ",(0,c.jsx)(i.code,{children:"BinLog"})," API, cache invalidation can be guaranteed to eventually succeed."]}),"\n",(0,c.jsx)(i.h2,{id:"consistency-of-transaction-trigger",children:"Consistency of Transaction Trigger"}),"\n",(0,c.jsxs)(i.p,{children:["When ",(0,c.jsx)(i.code,{children:"trigger-type"})," is ",(0,c.jsx)(i.code,{children:"TRANSACTION_ONLY"}),", Jimmer will be ",(0,c.jsx)(i.strong,{children:"forced"})," to use the Transaction trigger to invalidate caches."]}),"\n",(0,c.jsx)(i.p,{children:"For Transaction triggers:"}),"\n",(0,c.jsxs)(i.ul,{children:["\n",(0,c.jsxs)(i.li,{children:["\n",(0,c.jsx)(i.p,{children:"Only modifying the database through Jimmer's own API can trigger all callback behaviors."}),"\n"]}),"\n",(0,c.jsxs)(i.li,{children:["\n",(0,c.jsx)(i.p,{children:"All trigger callbacks complete before the transaction is committed."}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(i.p,{children:"If a simple implementation of direct cache invalidation is adopted, any exception during cache invalidation will cause the transaction to be rolled back. Obviously, this implementation is not reasonable."}),"\n",(0,c.jsxs)(i.p,{children:["Therefore, when ",(0,c.jsx)(i.code,{children:"trigger-type"})," is ",(0,c.jsx)(i.code,{children:"TRANSACTION_ONLY"}),", the cache invalidation operations perceived by the user will be delayed, they will not be executed immediately, but are stored in the ",(0,c.jsx)(i.code,{children:"JIMMER_TRANS_CACHE_OPERATOR"})," table."]}),"\n",(0,c.jsxs)(i.admonition,{type:"caution",children:[(0,c.jsx)(i.mdxAdmonitionTitle,{}),(0,c.jsxs)(i.p,{children:["Jimmer will automatically create the ",(0,c.jsx)(i.code,{children:"JIMMER_TRANS_CACHE_OPERATOR"})," table."]}),(0,c.jsxs)(i.p,{children:["However, the default ",(0,c.jsx)(i.code,{children:"org.babyfish.jimmer.sql.dialect.DefaultDialect"})," does not support this operation and will throw an exception."]}),(0,c.jsxs)(i.p,{children:["Therefore, if cache consistency needs to be driven by transaction trigger, don't use the default ",(0,c.jsx)(i.code,{children:"DefaultDialect"}),", please explicitly specify the database dialect."]})]}),"\n",(0,c.jsxs)(i.p,{children:["Modifications to the ",(0,c.jsx)(i.code,{children:"JIMMER_TRANS_CACHE_OPERATOR"})," table and business tables belong to the same database local transaction, either both succeed or both fail."]}),"\n",(0,c.jsxs)(i.p,{children:["After the transaction commits successfully, Jimmer will immediately execute a ",(0,c.jsx)(i.code,{children:"Flush"})," operation."]}),"\n",(0,c.jsxs)(i.p,{children:["The so-called ",(0,c.jsx)(i.code,{children:"Flush"})," operation is to query cache invalidation operations that have not yet been executed from the ",(0,c.jsx)(i.code,{children:"JIMMER_TRANS_CACHE_OPERATOR"})," table, execute the actual cache invalidation operation, and delete related records if successful."]}),"\n",(0,c.jsxs)(i.p,{children:["For the ",(0,c.jsx)(i.code,{children:"Flush"})," operation executed immediately after transaction commit:"]}),"\n",(0,c.jsxs)(i.ul,{children:["\n",(0,c.jsxs)(i.li,{children:["\n",(0,c.jsx)(i.p,{children:"If successful, it's best to have good real-time. This should be the case most of the time."}),"\n"]}),"\n",(0,c.jsxs)(i.li,{children:["\n",(0,c.jsxs)(i.p,{children:["Even if it fails, it doesn't matter. Jimmer will periodically execute ",(0,c.jsx)(i.code,{children:"Flush"})," operations to ensure related cache invalidation eventually succeed."]}),"\n",(0,c.jsxs)(i.p,{children:["The interval of ",(0,c.jsx)(i.code,{children:"Flush"})," operations is controlled by the global SpringBoot configuration item ",(0,c.jsx)(i.code,{children:"jimmer.transaction-cache-operator-fixed-delay"}),", which is specified in milliseconds and defaults to 5000."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,c.jsx)(i,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var n=t(96540);const c={},s=n.createContext(c);function a(e){const i=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);