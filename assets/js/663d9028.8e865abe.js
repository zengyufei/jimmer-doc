"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[9563],{10657:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"query/dynamic-join/kotlin-join","title":"Join Features Specific to Kotlin","description":"Dilemma","source":"@site/docs/query/dynamic-join/kotlin-join.mdx","sourceDirName":"query/dynamic-join","slug":"/query/dynamic-join/kotlin-join","permalink":"/jimmer-doc/docs/query/dynamic-join/kotlin-join","draft":false,"unlisted":false,"editUrl":"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/query/dynamic-join/kotlin-join.mdx","tags":[],"version":"current","lastUpdatedAt":1704015848000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Join Features Specific to Kotlin"},"sidebar":"tutorialSidebar","previous":{"title":"Weak Join","permalink":"/jimmer-doc/docs/query/dynamic-join/weak-join"},"next":{"title":"Implicit Subquery","permalink":"/jimmer-doc/docs/query/implicit-subquery"}}');var t=i(74848),o=i(28453);const s={sidebar_position:7,title:"Join Features Specific to Kotlin"},r=void 0,c={},a=[{value:"Dilemma",id:"dilemma",level:2},{value:"Getting Started with DSL&#39;s Null Safety",id:"getting-started-with-dsls-null-safety",level:2},{value:"Null Safety in Table Joins",id:"null-safety-in-table-joins",level:2},{value:"Inner Join",id:"inner-join",level:3},{value:"Left Join",id:"left-join",level:3}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"dilemma",children:"Dilemma"}),"\n",(0,t.jsx)(n.p,{children:"In order to take full advantage of Kotlin's language features and optimize its development experience, Jimmer provides different APIs for Java and Kotlin, but they are essentially the same."}),"\n",(0,t.jsx)(n.p,{children:"However, outer joins are the only exception. For this detail, the behaviors of Java API and Kotlin API are different:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Java DSL\nUse ",(0,t.jsx)(n.code,{children:"JoinType"})," to represent join type, which can be ",(0,t.jsx)(n.code,{children:"INNER"})," ",(0,t.jsx)(n.em,{children:"(default)"}),", ",(0,t.jsx)(n.code,{children:"LEFT"}),", ",(0,t.jsx)(n.code,{children:"RIGHT"})," or ",(0,t.jsx)(n.code,{children:"FULL"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Kotlin DSL"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Properties with the same name as entity properties represent inner joins"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Properties with a ",(0,t.jsx)(n.code,{children:"?"})," after the entity properties name represent left joins"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["That is, Kotlin DSL does not support ",(0,t.jsx)(n.code,{children:"RIGHT"})," and ",(0,t.jsx)(n.code,{children:"FULL"}),". This sacrifice is a careful trade-off, in exchange for a more important feature for Kotlin: perfectly combining Kotlin's null safety and SQL DSL."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"getting-started-with-dsls-null-safety",children:"Getting Started with DSL's Null Safety"}),"\n",(0,t.jsxs)(n.p,{children:["The entity ",(0,t.jsx)(n.code,{children:"BookStore"})," is defined as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@Entity\ninterface BookStore {\n\n    val name: String\n\n    val website: String?\n\n    // Omit other code\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The precompiled code generates:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'public val KNonNullProps<BookStore>.name: KNonNullPropExpression<String>\n    get() = get("name")\n\npublic val KNullableProps<BookStore>.name: KNullablePropExpression<String>\n    get() = get("name")\n\npublic val KProps<BookStore>.website: KNullablePropExpression<String>\n    get() = get("website")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Please ignore the details of the generated code for now. We can see many types containing ",(0,t.jsx)(n.code,{children:"NonNull"})," or ",(0,t.jsx)(n.code,{children:"Nullable"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["In Jimmer's Kotlin SQL DSL, almost all AST types have both ",(0,t.jsx)(n.code,{children:"NonNull"})," and ",(0,t.jsx)(n.code,{children:"Nullable"})," implementations."]}),(0,t.jsx)(n.p,{children:"This means Kotlin SQL DSL has null safety features equivalent to Kotlin language itself. SQL-style query code has complete null safety self-checking capabilities."})]}),"\n",(0,t.jsx)(n.p,{children:"Let's look at a simple example first:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val tuples = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.name,\n            table.website \u2776\n        )\n    }\n    .execute()\nfor ((name, website) in books) { \u2777\n    println("Length of name: ${name.length}")\n    // Compile error  \n    // highlight-next-line\n    println("Length of website: ${website.length}") \u2778\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Since ",(0,t.jsx)(n.code,{children:"BookStore.website"})," is nullable, the type of the second column selected at \u2776 is ",(0,t.jsx)(n.code,{children:"String?"})," instead of ",(0,t.jsx)(n.code,{children:"String"}),".\nThe final return type of the query is ",(0,t.jsx)(n.code,{children:"List<Tuple2<String, String?>>"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["\u2777 Loops through each tuple queried, destructuring into variables ",(0,t.jsx)(n.code,{children:"name"})," and ",(0,t.jsx)(n.code,{children:"website"}),".\nSince ",(0,t.jsx)(n.code,{children:"tuples"})," is of type ",(0,t.jsx)(n.code,{children:"List<Tuple2<String, String?>>"}),", here ",(0,t.jsx)(n.code,{children:"website"})," is of type ",(0,t.jsx)(n.code,{children:"String?"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["\u2778 Performs ",(0,t.jsx)(n.code,{children:".length"})," operation on potentially null ",(0,t.jsx)(n.code,{children:"website"}),", causing compile error."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To fix this compile error, modify code at \u2778 to change ",(0,t.jsx)(n.code,{children:"."})," to ",(0,t.jsx)(n.code,{children:"?."}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'println("Length of website: ${website?.length}")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"null-safety-in-table-joins",children:"Null Safety in Table Joins"}),"\n",(0,t.jsx)(n.p,{children:"In the above, we learned the simplest null safety in SQL DSL through a very simple example."}),"\n",(0,t.jsx)(n.p,{children:"Now, let's combine null safety with table join operations:"}),"\n",(0,t.jsx)(n.h3,{id:"inner-join",children:"Inner Join"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val tuples = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.name, \n            table.store.name \u2776\n        )\n    }\n    .execute()\nfor ((name, storeName) in books) { \u2777\n    println("Length of name: ${name.length}")\n    println("Length of storeName: ${storeName.length}") \u2778\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["\u2776 Uses inner join to get parent object's name. The final return type of the query is ",(0,t.jsx)(n.code,{children:"List<Tuple2<String, String>>"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["\u2777 Destructures into variables ",(0,t.jsx)(n.code,{children:"storeName"})," of type ",(0,t.jsx)(n.code,{children:"String"}),", non-nullable. So code at \u2778 compiles."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"left-join",children:"Left Join"}),"\n",(0,t.jsx)(n.p,{children:"Let's modify the code to change inner join to outer join:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val tuples = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.name,\n            table.`store?`.name \u2776\n        ) \n    }\n    .execute()\nfor ((name, storeName) in books) { \u2777\n    println("Length of name: ${name.length}")\n    // Compile error\n    // highlight-next-line  \n    println("Length of storeName: ${storeName.length}") \u2778\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"\u2776 Uses left join to get parent object."}),"\n",(0,t.jsxs)(n.p,{children:["The precompiled code in ",(0,t.jsx)(n.code,{children:"BookProps.kt"})," includes:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'public val KProps<Book>.store: KNonNullTable<BookStore>\n    get() = join("store")\n\npublic val KProps<Book>.`store?`: KNullableTable<BookStore>  \n    get() = outerJoin("store")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Unlike inner join ",(0,t.jsx)(n.code,{children:"store"}),", outer join ",(0,t.jsx)(n.code,{children:"store?"})," returns a table of type ",(0,t.jsx)(n.code,{children:"KNullableTable"}),", i.e. nullable table. This is the effect of left join in SQL."]}),"\n",(0,t.jsxs)(n.p,{children:["The precompiled code in ",(0,t.jsx)(n.code,{children:"BookStoreProps.kt"})," includes:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'public val KNonNullProps<BookStore>.name: KNonNullPropExpression<String>\n    get() = get("name") \u2779\n\npublic val KNullableProps<BookStore>.name: KNullablePropExpression<String>\n    get() = get("name") \u277a\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The returned ",(0,t.jsx)(n.code,{children:"KNullableTable"})," inherits from ",(0,t.jsx)(n.code,{children:"KNullableProps"})," instead of ",(0,t.jsx)(n.code,{children:"KNonNullProps"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["So in the DSL, accessing ",(0,t.jsx)(n.code,{children:"name"})," matches \u277a instead of \u2779."]}),"\n",(0,t.jsxs)(n.p,{children:["That is, just ",(0,t.jsx)(n.code,{children:"BookStore.name"})," being non-null is not enough, need to also consider if the table it is accessed from is non-null."]}),"\n",(0,t.jsxs)(n.p,{children:["Ultimately, Jimmer determines the second column in \u2776 is ",(0,t.jsx)(n.code,{children:"String?"}),", so the return type is ",(0,t.jsx)(n.code,{children:"List<Tuple2<String, String?>>"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["\u2777 Destructures into ",(0,t.jsx)(n.code,{children:"storeName"})," of type ",(0,t.jsx)(n.code,{children:"String?"}),", nullable. This must cause compile error at \u2778."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To fix this compile error, modify code at \u2778 to change ",(0,t.jsx)(n.code,{children:"."})," to ",(0,t.jsx)(n.code,{children:"?."}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'println("Length of storeName: ${storeName?.length}") \u2778  \n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var l=i(96540);const t={},o=l.createContext(t);function s(e){const n=l.useContext(o);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),l.createElement(o.Provider,{value:n},e.children)}}}]);